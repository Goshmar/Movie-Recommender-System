# -*- coding: utf-8 -*-
"""5-evaluation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rpcuJXGZE22Wodn4A6200BFzUud48DOO
"""

import os

repo_dir = "Movie-Recommender-System"

if os.path.exists(repo_dir):
    print(f"{repo_dir} already exists. Removing it...\n")
    !rm -r {repo_dir}

# Clone the repository from GitHub
!git clone https://github.com/Goshmar/Movie-Recommender-System

!pip install surprise -q

import requests
import zipfile
import pandas as pd
import numpy as np

# Define the paths
zip_file_path = "/content/Movie-Recommender-System/data/raw/ml-100k.zip"

with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(".")

# ZIP cleaning up
os.remove(zip_file_path)

item_info = pd.read_csv('/content/ml-100k/u.item', sep='|', encoding='latin-1', names=['movie_id', 'movie_title', 'release_date', 'video_release_date', 'IMDB_URL', 'unknown', 'Action', 'Adventure', 'Animation', 'Children', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy', 'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western'])

import pandas as pd
import numpy as np

# Download data
trainset = pd.read_csv("/content/Movie-Recommender-System/data/interim/trainset.csv")
testset = pd.read_csv("/content/Movie-Recommender-System/data/interim/testset.csv")
feature_matrix = pd.read_csv("/content/Movie-Recommender-System/data/interim/feature_matrix.csv")
rating_matrix = pd.read_csv("/content/Movie-Recommender-System/data/interim/rating_matrix.csv")

# Download benchmark data
rec_svd_df = pd.read_csv("/content/Movie-Recommender-System/benchmark/data/rec_svd_df_Lord of Illusions.csv")
rec_hybrid_svd = pd.read_csv("/content/Movie-Recommender-System/benchmark/data/rec_hybrid_svd_df_Lord of Illusions.csv")

from surprise import Dataset
from surprise.model_selection import train_test_split
from surprise import SVD
from surprise import accuracy

# Load the MovieLens 100K dataset
data = Dataset.load_builtin('ml-100k')
trainset, testset = train_test_split(data, test_size=0.2)

# Build and train the SVD model
model_svd = SVD(n_factors=50)
model_svd.fit(trainset)

# Make predictions on the test set
predictions_svd = model_svd.test(testset)

# Calculate and print RMSE
rmse_svd = accuracy.rmse(predictions_svd)
print("SVD RMSE:", rmse_svd)

from scipy.sparse.linalg import spsolve_triangular
from scipy.sparse import csr_matrix

# Calculate SVD for the rating matrix
u, s, vt = np.linalg.svd(rating_matrix.values, full_matrices=False)
v = vt.T[:, :50]

# Item similarity matrix
d = 0.5  # off-diagonal similarity factor
item_similarity_matrix = np.eye(feature_matrix.shape[1])
item_similarity_matrix[-1, -3] = d
item_similarity_matrix[-3, -1] = d

# Finding Cholesky factors
L = np.linalg.cholesky(item_similarity_matrix)

# Update this line to match the shape of the feature matrix
u2, s2, v2 = np.linalg.svd(np.dot(feature_matrix.values, L), full_matrices=False)
v2 = v2.T[:, :50]

# Preparing for hybrid folding-in calculation
lv = np.dot(L, v2)
rv = spsolve_triangular(csr_matrix(L.T), v2, lower=False)

predictions_hybrid = np.dot(feature_matrix.values, lv).dot(rv.T).flatten()

test_predictions = []
for uid, iid, true_r, est, _ in predictions_svd:
    movie_index = item_info[item_info['movie_id'] == int(iid)].index
    if not movie_index.empty and movie_index[0] in feature_matrix.index:
        pred_hybrid = predictions_hybrid[movie_index[0]]
        test_predictions.append((uid, iid, true_r, est, pred_hybrid))

# Calculate and print RMSE for the hybrid model
rmse_hybrid = accuracy.rmse(test_predictions)
print("Hybrid SVD RMSE:", rmse_hybrid)

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Extract true ratings and estimated ratings from predictions
true_ratings = np.array([true_r for _, _, true_r, _, _ in test_predictions])
estimated_ratings_svd = np.array([est for _, _, _, est, _ in test_predictions])
estimated_ratings_hybrid = np.array([pred_hybrid for _, _, _, _, pred_hybrid in test_predictions])

# Create a scatter plot
plt.figure(figsize=(12, 8))
sns.scatterplot(x=true_ratings, y=estimated_ratings_svd, label='SVD Predictions', alpha=0.7, marker='o')
sns.scatterplot(x=true_ratings, y=estimated_ratings_hybrid, label='Hybrid SVD Predictions', alpha=0.7, marker='s')

# Plot a diagonal line representing perfect predictions
plt.plot([min(true_ratings), max(true_ratings)], [min(true_ratings), max(true_ratings)], linestyle='--', color='gray', label='Perfect Prediction')

plt.title('True Ratings vs Predicted Ratings')
plt.xlabel('True Ratings')
plt.ylabel('Predicted Ratings')
plt.legend()
plt.yscale('log')
plt.grid(True)
plt.show()